#include <windows.h>
#include <stdio.h>
#include <bncs_string.h>
#include <bncs_config.h>
#include "interop_crosspoint.h"

#define PNL_MAIN	1

#define TIMER_SETUP	1

// this nasty little macro to make our class visible to the outside world
EXPORT_BNCS_SCRIPT( interop_crosspoint )

// constructor - equivalent to ApplCore STARTUP
interop_crosspoint::interop_crosspoint( bncs_client_callback * parent, const char * path ) : bncs_script_helper( parent, path )
{
	// show a panel from file p1.bncs_ui and we'll know it as our panel PNL_MAIN
	panelShow( PNL_MAIN, "p1.bncs_ui" );

	// you may need this call to set the size of this component 
	//  if it's used in a popup window 
//	setSize( 1024,668 );		// set the size explicitly
//	setSize( PNL_MAIN );		// set the size to the same as the specified panel
	m_intDevice = 0;
	m_strDestinationType = bncs_string((""));
	m_intSourceIndex = 0;
	m_intDestinationIndex = 0;
	m_boolCrosspoint = false;
	m_intSlot = 0;
	timerStart(TIMER_SETUP, 100);

}

// destructor - equivalent to ApplCore CLOSEDOWN
interop_crosspoint::~interop_crosspoint()
{
}

// all button pushes and notifications come here
void interop_crosspoint::buttonCallback( buttonNotify *b )
{
	if( b->panel() == PNL_MAIN ) {
		if (b->id() == "btn") {
			//toggle by sending opposite of current state
			infoWrite(m_intDevice, m_boolCrosspoint ? "0" : "1", m_intSlot);
		}
	}
}

// all revertives come here
int interop_crosspoint::revertiveCallback( revertiveNotify * r ) {
	if (r->device() == m_intDevice) {
		debug("interop_crosspoint::revertiveCallback index: %1, value: %1\n", r->index(), r->sInfo());
		if (r->index() == m_intSlot) {
			m_boolCrosspoint = r->sInfo() == "1";
			textPut("statesheet", r->sInfo() == "0" ? "crosspoint_off" : "crosspoint_on", PNL_MAIN, "btn");
		}
	}
	return 0;
}

// all database name changes come back here
void interop_crosspoint::databaseCallback( revertiveNotify * r )
{
}

// all parent notifications come here i.e. when this script is just one 
//  component of another dialog then our host might want to tell us things
bncs_string interop_crosspoint::parentCallback( parentNotify *p )
{
	if( p->command() == "return" )
	{
		if( p->value() == "all" )
		{	// Persisting values for bncs_vis_ed
			bncs_stringlist sl;
			//sl << bncs_string("myParam=%1").arg(m_myParam);
			sl << bncs_string("DestinationType=%1").arg(m_strDestinationType);
			sl << bncs_string("SourceIndex=%1").arg(bncs_string(m_intSourceIndex));
			sl << bncs_string("DestinationIndex=%1").arg(bncs_string(m_intDestinationIndex));
			return sl.toString( '\n' );
		}

		/*else if( p->value() == "myParam" )
		{	// Specific value being asked for by a textGet
			return( bncs_string( "%1=%2" ).arg( p->value() ).arg( m_myParam ) );
		}*/

	}
	else if( p->command() == "instance" && p->value() != m_instance )
	{	// Our instance is being set/changed
		m_instance = p->value();
		//Do something instance-change related here
		getDev(m_instance, &m_intDevice);
	}

	else if( p->command() == "DestinationType" ) {
		m_strDestinationType = p->value();
	}

	else if (p->command() == "SourceIndex") {
		m_intSourceIndex = int(p->value());
	}

	else if (p->command() == "DestinationIndex") {
		m_intDestinationIndex = int(p->value());
	}

	// ***** CONNECTIONS EVENTS HELPER LIST *****
	else if( p->command() == "_events" )
	{	// Helper-list of everything in this component generated by hostNotify's
		bncs_stringlist sl;

		sl << "notify=*";		
		
		return sl.toString( '\n' );
	}

	// ***** CONNECTIONS COMMANDS HELPER LIST *****
	else if( p->command() == "_commands" )
	{	// Helper-list of any commands/parameters you might want to set at run-time
		bncs_stringlist sl;
		
		//sl << "myParam=[value]";
		
		return sl.toString( '\n' );
	}

	return "";
}

// timer events come here
void interop_crosspoint::timerCallback( int id )
{
	switch( id )
	{
	case TIMER_SETUP:
		timerStop(id);
		if (m_strDestinationType == "master") {
			if (m_intSourceIndex == m_intDestinationIndex) {
				controlDisable(PNL_MAIN, "btn");
			}
			m_intSlot = getMasterMasterMatrixSlot(m_intSourceIndex, m_intDestinationIndex);
		} else if (m_strDestinationType == "slave") {
			m_intSlot = getMasterSlaveMatrixSlot(m_intSourceIndex, m_intDestinationIndex);
		}
		textPut("text", bncs_string(m_intSourceIndex), PNL_MAIN, "btn");
		if (m_intSlot > 0) {
			infoRegister(m_intDevice, m_intSlot, m_intSlot);
			infoPoll(m_intDevice, m_intSlot, m_intSlot);
			textPut("text", bncs_string(m_intSourceIndex), PNL_MAIN, "btn");
		}
		else {
			textPut("text", bncs_string("*"), PNL_MAIN, "btn");
		}
		break;

	default:	// Unhandled timer event
		timerStop(id);
		break;
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Callbacks above - Methods below ///////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

int interop_crosspoint::getMasterMasterMatrixSlot(int source, int dest) {
	return (MASTER_MASTER_MATRIX_TABLE + (MASTER_COUNT * source) + dest);
}

int interop_crosspoint::getMasterSlaveMatrixSlot(int source, int dest) {
	return (MASTER_SLAVE_MATRIX_TABLE + (SLAVE_COUNT * source) + dest);
}


