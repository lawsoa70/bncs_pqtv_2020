#include <windows.h>
#include <stdio.h>
#include <bncs_string.h>
#include <bncs_config.h>
#include "interop_lights.h"

#define PNL_MAIN	1

#define TIMER_SETUP	1

// this nasty little macro to make our class visible to the outside world
EXPORT_BNCS_SCRIPT( interop_lights )

// constructor - equivalent to ApplCore STARTUP
interop_lights::interop_lights( bncs_client_callback * parent, const char * path ) : bncs_script_helper( parent, path )
{
	// show a panel from file p1.bncs_ui and we'll know it as our panel PNL_MAIN
	panelShow( PNL_MAIN, "p1.bncs_ui" );

	// you may need this call to set the size of this component 
	//  if it's used in a popup window 
//	setSize( 1024,668 );		// set the size explicitly
//	setSize( PNL_MAIN );		// set the size to the same as the specified panel
	m_intDevice = 0;
	m_strMasterOrSlave = "";
	m_intIndex = 0;
	m_boolBlueState = false;
	m_boolRedState = false;
	m_intBlueSlot = 0;
	m_intRedSlot = 0;
	timerStart(TIMER_SETUP, 100);

}

// destructor - equivalent to ApplCore CLOSEDOWN
interop_lights::~interop_lights()
{
}

// all button pushes and notifications come here
void interop_lights::buttonCallback( buttonNotify *b )
{
	if( b->panel() == PNL_MAIN )
	{
	}
}

// all revertives come here
int interop_lights::revertiveCallback( revertiveNotify * r )
{
	if (r->device() == m_intDevice) {
		debug("interop_lights::revertiveCallback slot: %1, value: %1\n", r->index(), r->sInfo());
		if (r->index() == m_intBlueSlot) {
			m_boolBlueState = r->sInfo() == "1" ? true : false;
			textPut("colour.background", r->sInfo() == "1" ? "blue" : "", PNL_MAIN, "lbl_blue");
		} else if (r->index() == m_intRedSlot) {
			m_boolRedState = r->sInfo() == "1" ? true : false;
			textPut("colour.background", r->sInfo() == "1" ? "red" : "", PNL_MAIN, "lbl_red");
		}
	}
	return 0;
}

// all database name changes come back here
void interop_lights::databaseCallback( revertiveNotify * r )
{
}

// all parent notifications come here i.e. when this script is just one 
//  component of another dialog then our host might want to tell us things
bncs_string interop_lights::parentCallback( parentNotify *p )
{
	if( p->command() == "return" )
	{
		if( p->value() == "all" )
		{	// Persisting values for bncs_vis_ed
			bncs_stringlist sl;
			//sl << bncs_string( "myParam=%1" ).arg( m_myParam );
			sl << bncs_string("MasterOrSlave=%1").arg(m_strMasterOrSlave);
			sl << bncs_string("Index=%1").arg(m_intIndex);
			return sl.toString('\n');
		}

		/*else if( p->value() == "myParam" )
		{	// Specific value being asked for by a textGet
			return( bncs_string( "%1=%2" ).arg( p->value() ).arg( m_myParam ) );
		}*/

	}
	else if( p->command() == "instance" && p->value() != m_instance )
	{	// Our instance is being set/changed
		m_instance = p->value();
		//Do something instance-change related here
		getDev(m_instance, &m_intDevice);
	}

	else if( p->command() == "MasterOrSlave" ) {
		bncs_string l = p->value().lower();
		if (l == "master" || l == "slave") {
			m_strMasterOrSlave = l;
		}
	}

	else if (p->command() == "Index") {
		m_intIndex = int(p->value());
	}

	// ***** CONNECTIONS EVENTS HELPER LIST *****
	else if( p->command() == "_events" )
	{	// Helper-list of everything in this component generated by hostNotify's
		bncs_stringlist sl;

		sl << "notify=*";		
		
		return sl.toString( '\n' );
	}

	// ***** CONNECTIONS COMMANDS HELPER LIST *****
	else if( p->command() == "_commands" )
	{	// Helper-list of any commands/parameters you might want to set at run-time
		bncs_stringlist sl;
		
		sl << "myParam=[value]";
		
		return sl.toString( '\n' );
	}

	return "";
}

// timer events come here
void interop_lights::timerCallback( int id )
{
	switch( id )
	{
	case TIMER_SETUP:
		timerStop(id);
		if (m_strMasterOrSlave == "master") {
			m_intBlueSlot = getMasterBlueSlot(m_intIndex);
			if (m_intBlueSlot > 0) {
				infoRegister(m_intDevice, m_intBlueSlot, m_intBlueSlot);
				infoPoll(m_intDevice, m_intBlueSlot, m_intBlueSlot);
				debug("interop_lights::setup reg and poll master blue slot*: %1\n", m_intBlueSlot);
			}
			m_intRedSlot = getMasterRedSlot(m_intIndex);
			if (m_intRedSlot > 0) {
				infoRegister(m_intDevice, m_intRedSlot, m_intRedSlot, true);
				infoPoll(m_intDevice, m_intRedSlot, m_intRedSlot);
				debug("interop_lights::setup reg and poll master red slot: %1\n", m_intRedSlot);
			}
		} else if (m_strMasterOrSlave == "slave") {
			m_intBlueSlot = getSlaveBlueSlot(m_intIndex);
			if (m_intBlueSlot > 0) {
				infoRegister(m_intDevice, m_intBlueSlot, m_intBlueSlot);
				infoPoll(m_intDevice, m_intBlueSlot, m_intBlueSlot);
				debug("interop_lights::setup reg and poll slave blue slot: %1\n", m_intBlueSlot);
			}
			m_intRedSlot = getSlaveRedSlot(m_intIndex);
			if (m_intRedSlot > 0) {
				infoRegister(m_intDevice, m_intRedSlot, m_intRedSlot, true);
				infoPoll(m_intDevice, m_intRedSlot, m_intRedSlot);
				debug("interop_lights::setup reg and poll slave red slot: %1\n", m_intRedSlot);
			}
		}
		break;

	default:	// Unhandled timer event
		timerStop(id);
		break;
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Callbacks above - Methods below ///////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

int interop_lights::getMasterBlueSlot(int master) {
	return (MASTER_BLUE_TABLE + master);
}

int interop_lights::getMasterRedSlot(int master) {
	return (MASTER_RED_TABLE + master);
}

int interop_lights::getSlaveBlueSlot(int slave) {
	return (SLAVE_BLUE_TABLE + slave);
}

int interop_lights::getSlaveRedSlot(int slave) {
	return (SLAVE_RED_TABLE + slave);
}


