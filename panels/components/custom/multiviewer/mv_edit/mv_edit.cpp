#include <windows.h>
#include <stdio.h>
#include <bncs_string.h>
#include <bncs_config.h>
#include "mv_edit.h"

#define PNL_MAIN	1
#define PNL_MV_POPUP 2

#define TIMER_SETUP	1

// this nasty little macro to make our class visible to the outside world
EXPORT_BNCS_SCRIPT( mv_edit )

// constructor - equivalent to ApplCore STARTUP
mv_edit::mv_edit( bncs_client_callback * parent, const char * path ) : bncs_script_helper( parent, path )
{
	// show a panel from file p1.bncs_ui and we'll know it as our panel PNL_MAIN
	panelShow( PNL_MAIN, "p1.bncs_ui" );

	// you may need this call to set the size of this component 
	//  if it's used in a popup window 
	//	setSize( 1024,668 );		// set the size explicitly
	setSize( PNL_MAIN );		// set the size to the same as the specified panel

	m_intSelectedDest = -1;
	m_intSelectedSource = -1;
	controlDisable(PNL_MAIN, "btn_edit");
	textPut("text", "Edit MV", PNL_MAIN, "btn_edit");

	m_strArea = getWorkstationSetting("ops_area");
	bncs_string strMvSettings = bncs_string("%1_multiviewers").arg(m_strArea); // e.g list = "studio_b_multiviewers"
	m_strInstance = getObjectSetting(strMvSettings, "router");
	getDev(m_strInstance, &m_intDevice);
	m_intTallyDatabase = getObjectSetting(strMvSettings, "tally_database");
	int n = 1;
	bncs_string s = getObjectSetting(strMvSettings, bncs_string("mv_%1").arg(n));  // e.g. s = "studio_b_mv_1"
	m_slMvList = "";
	while (s.length() > 0) {
		m_slMvSourceList << getObjectSetting(s, "output");
		m_slMvList << s;
		n++;
		s = getObjectSetting(strMvSettings, bncs_string("mv_%1").arg(n));  // e.g. s = "studio_b_mv_2"
	}
	//debug(bncs_string("\nList: <%1>\n").arg(m_slMvList));
}

// destructor - equivalent to ApplCore CLOSEDOWN
mv_edit::~mv_edit()
{
}

// all button pushes and notifications come here
void mv_edit::buttonCallback( buttonNotify *b ) {
	if (b->panel() == PNL_MAIN) {
		if (b->id() == "btn_edit") {
			int i = m_slMvSourceList.find(m_intSelectedSource);
			if (i > -1) {
				debug(bncs_string("\nParam: <%1>\n").arg(m_slMvList[i]));
				debug(bncs_string("\nmv_select,%1\n").arg(m_slMvList[i]));
				navigateExecute(bncs_string("mv_select,%1").arg(m_slMvList[i]));
			}
		}
	}
}

// all revertives come here
int mv_edit::revertiveCallback( revertiveNotify * r )
{
	if (r->device() == m_intDevice && r->index() == m_intSelectedDest) {
		m_intSelectedSource = r->info();
		if (m_slMvSourceList.find(m_intSelectedSource) > -1) {
			bncs_string ret;
			routerName(m_intDevice, m_intTallyDatabase, m_intSelectedSource, ret);
			textPut("text", bncs_string("Edit %1").arg(ret), 
				PNL_MAIN, "btn_edit");
			controlEnable(PNL_MAIN, "btn_edit");
		}
		else {
			controlDisable(PNL_MAIN, "btn_edit");
			textPut("text", "Edit MV", PNL_MAIN, "btn_edit");
		}
	}
	return 0;
}

// all database name changes come back here
void mv_edit::databaseCallback( revertiveNotify * r )
{
}

// all parent notifications come here i.e. when this script is just one 
//  component of another dialog then our host might want to tell us things
bncs_string mv_edit::parentCallback( parentNotify *p )
{
	//debug(bncs_string("\nCommand: %1 Sub: %2 Value: %3\n").arg(p->command()).arg(p->sub(0)).arg(p->value()));
	if( p->command() == "return" )
	{
		if( p->value() == "all" )
		{	// Persisting values for bncs_vis_ed
			bncs_stringlist sl;
			//sl << bncs_string( "myParam=%1" ).arg( m_myParam );
			return sl.toString( '\n' );
		}
		/*
		else if( p->value() == "myParam" )
		{	// Specific value being asked for by a textGet
			return( bncs_string( "%1=%2" ).arg( p->value() ).arg( m_myParam ) );
		}
		*/
	}
	else if( p->command() == "instance" && p->value() != m_strInstance )
	{	// Our instance is being set/changed
		//Do something instance-change related here
	}

	/*
	else if( p->command() == "myParam" )
	{	// Persisted value or 'Command' being set here
		m_myParam = p->value();
	}
	*/

	else if (p->command() == "selected_dest")
	{	// Persisted value or 'Command' being set here
		m_intSelectedDest = p->value();
		routerRegister(m_intDevice, m_intSelectedDest, m_intSelectedDest);
		routerPoll(m_intDevice, m_intSelectedDest, m_intSelectedDest);
	}

	// ***** CONNECTIONS EVENTS HELPER LIST *****
	else if( p->command() == "_events" )
	{	// Helper-list of everything in this component generated by hostNotify's
		bncs_stringlist sl;
		sl << "notify=*";		
		return sl.toString( '\n' );
	}

	// ***** CONNECTIONS COMMANDS HELPER LIST *****
	else if( p->command() == "_commands" )
	{	// Helper-list of any commands/parameters you might want to set at run-time
		bncs_stringlist sl;
		sl << "myParam=[value]";
		return sl.toString( '\n' );
	}

	return "";
}

// timer events come here
void mv_edit::timerCallback( int id )
{
	switch( id )
	{
	case TIMER_SETUP:
		timerStop(id);
		break;

	default:	// Unhandled timer event
		timerStop(id);
		break;
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Callbacks above - Methods below ///////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


