#include <windows.h>
#include <stdio.h>
#include <bncs_string.h>
#include <bncs_config.h>
#include "deviceStatus.h"

std::map< unsigned int, bncs_string> deviceStatus::m_workstations;

#define PNL_MAIN	1
#define TIMER_SETUP	1

// this nasty little macro to make our class visible to the outside world
EXPORT_BNCS_SCRIPT( deviceStatus )

// constructor - equivalent to ApplCore STARTUP
deviceStatus::deviceStatus( bncs_client_callback * parent, const char * path ) : bncs_script_helper( parent, path )
{
	// show a panel from file deviceStatus.bncs_ui and we'll know it as our panel PNL_MAIN
	panelShow( PNL_MAIN, "deviceStatus.bncs_ui" );

	m_device = 0;
	m_deviceStatusId = 0;

	// get our fixed deviceStatus device ID
	getDev("deviceStatus", &m_deviceStatusId);

	// our list of workstations is STATIC, so if the list is empty, go try and load it (but don't bother if it's already loaded)
	if (!m_workstations.size())
	{
		bncs_config c("workstations");
		while (c.isChildValid())
		{
			m_workstations.insert(std::pair< unsigned int, bncs_string>(c.childAttr("id").toInt(), c.childAttr("name")));
			c.nextChild();
		}
	}
}

// destructor - equivalent to ApplCore CLOSEDOWN
deviceStatus::~deviceStatus()
{
}

// all button pushes and notifications come here
void deviceStatus::buttonCallback( buttonNotify *b )
{
}




// all revertives come here
int deviceStatus::revertiveCallback(revertiveNotify * r)
{
	if (r->device() == m_deviceStatusId && r->index() == m_device )
	{
		if (r->sInfo().startsWith("starting"))
		{
			textPut("text", "Wait...", PNL_MAIN, 1);
			textPut("stylesheet=background_discrete", PNL_MAIN, 1);
		}
		else
		{
		bncs_stringlist sl(r->sInfo());

			bncs_string out;

			int txHosts = 0;
			int rxHosts = 0;
			for (bncs_stringlist::iterator it = sl.begin(); it != sl.end(); ++it)
			{
				bncs_string entry = *it;
				if (entry.length())
				{
					bncs_string suffix;

					if (entry.endsWith("T"))
					{
						txHosts++;
						suffix = "TX";
					}
					else if (entry.endsWith("R"))
					{
						rxHosts++;
						suffix = "rx";
					}
					else if (entry.endsWith("B"))
					{
						rxHosts++;
						suffix = "Broken!";
					}
					int ws = entry.firstInt();

					std::map<unsigned int, bncs_string>::const_iterator it = m_workstations.find(ws);
					if (it != m_workstations.end())
					{
						if (out.length())
							out += ", ";
						out += it->second + " (" + suffix + ")";
					}
					else
					{
						if (out.length())
							out += ", ";
						out += bncs_string("workstation") + ws + " (" + suffix + ")";
					}

				}
			}
			if (txHosts == 1)
			{
				textPut("text", "Running on: " + out, PNL_MAIN, 1);
				textPut("stylesheet=background_discrete", PNL_MAIN, 1);
			}
			else
			{
				textPut("text", "Driver Error " + out, PNL_MAIN, 1);
				textPut("stylesheet=enum_alarm", PNL_MAIN, 1);
			}
		}
	}
	return 0;
}
// all database name changes come back here
void deviceStatus::databaseCallback( revertiveNotify * r )
{
}

// all parent notifications come here i.e. when this script is just one 
//  component of another dialog then our host might want to tell us things
bncs_string deviceStatus::parentCallback( parentNotify *p )
{
	p->dump();

	if( p->command() == "return" )
	{
		if( p->value() == "all" )
		{	// Persisting values for bncs_vis_ed
			bncs_stringlist sl;
			
//			sl << bncs_string( "panel=%1" ).arg( m_panel);
			
			return sl.toString( '\n' );
		}

/*		else if( p->value() == "panel" )
		{	// Specific value being asked for by a textGet
			return( bncs_string( "%1=%2" ).arg( p->value() ).arg( m_panel ) );
		}
*/

	}
	else if( p->command() == "instance" && p->value() != m_instance )
	{	// Our instance is being set/changed
		m_instance = p->value();

		if (m_deviceStatusId)
		{
			infoUnregister(m_deviceStatusId);
		}

		m_device = 0;
		getDev(m_instance, &m_device);

		if (m_deviceStatusId && m_device )
		{
			infoRegister(m_deviceStatusId, m_device, m_device);
			infoPoll(m_deviceStatusId, m_device, m_device);
		}
	}

/*	else if( p->command() == "panel" )
	{	// Persisted value or 'Command' being set here
		m_panel = p->value();
	}
*/
	// ***** CONNECTIONS EVENTS HELPER LIST *****
	else if( p->command() == "_events" )
	{	// Helper-list of everything in this component generated by hostNotify's
		bncs_stringlist sl;

//		sl << "notify=*";		
		
		return sl.toString( '\n' );
	}

	// ***** CONNECTIONS COMMANDS HELPER LIST *****
	else if( p->command() == "_commands" )
	{	// Helper-list of any commands/parameters you might want to set at run-time
		bncs_stringlist sl;
		
//		sl << "myParam=[value]";
		
		return sl.toString( '\n' );
	}

	return "";
}

// timer events come here
void deviceStatus::timerCallback( int id )
{
	switch( id )
	{
	case TIMER_SETUP:
		timerStop(id);
		break;

	default:	// Unhandled timer event
		timerStop(id);
		break;
	}
}

