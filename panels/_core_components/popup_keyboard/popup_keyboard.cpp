#include <windows.h>
#include <stdio.h>
#include <bncs_string.h>
#include <bncs_config.h>
#include "popup_keyboard.h"

#define PNL_MAIN	1

#define TIMER_SETUP	1

// this nasty little macro to make our class visible to the outside world
EXPORT_BNCS_SCRIPT( popup_keyboard )

// constructor - equivalent to ApplCore STARTUP
popup_keyboard::popup_keyboard( bncs_client_callback * parent, const char * path ) : bncs_script_helper( parent, path )
{
	// show a panel from file popup_keyboard.bncs_ui and we'll know it as our panel PNL_MAIN
//	debug("popup_keyboard::constructor");
	panelShow( PNL_MAIN, "popup_keyboard.bncs_ui" );
	
	// you may need this call to set the size of this component 
	//  if it's used in a popup window 
	//	setSize( 1024,668 );		// set the size explicitly
	setSize( PNL_MAIN );		// set the size to the same as the specified panel
}

// destructor - equivalent to ApplCore CLOSEDOWN
popup_keyboard::~popup_keyboard()
{
}

// all button pushes and notifications come here
void popup_keyboard::buttonCallback( buttonNotify *b )
{
	debug(bncs_string("popup_keyboard::buttonCallback id=%1 command=%2.%3 value=%2").arg(b->id()).arg(b->command()).arg(b->sub(0)).arg(b->value()));
	
	if( b->panel() == PNL_MAIN )
	{
		bncs_string valuetext="";
		
		if ( b->id() == "close")
		{
			hostNotify("dismiss");
		}
		else
		{
			textGet( "text", PNL_MAIN, b->id(), valuetext );
			hostNotify(bncs_string( "value=%1" ).arg(valuetext));
			hostNotify("dismiss");
		}
	}
}

// all revertives come here
int popup_keyboard::revertiveCallback( revertiveNotify * r )
{
/*	switch( r->device() )
	{
		case 123:
 			textPut( "text", r->sInfo(), 1, 3 );
			break;
	}
*/	return 0;
}

// all database name changes come back here
void popup_keyboard::databaseCallback( revertiveNotify * r )
{
}

// all parent notifications come here i.e. when this script is just one 
//  component of another dialog then our host might want to tell us things
bncs_string popup_keyboard::parentCallback( parentNotify *p )
{
	if( p->command() == "return" )
	{
		if( p->value() == "all" )
		{	// Persisting values for bncs_vis_ed
			bncs_stringlist sl;
			
			sl << bncs_string( "myParam=%1" ).arg( m_myParam );
			
			return sl.toString( '\n' );
		}

		else if( p->value() == "myParam" )
		{	// Specific value being asked for by a textGet
			return( bncs_string( "%1=%2" ).arg( p->value() ).arg( m_myParam ) );
		}
	}
	else if( p->command() == "instance" && p->value() != m_instance )
	{	// Our instance is being set/changed
		m_instance = p->value();
		//Do something instance-change related here
	}

	else if( p->command() == "default" )
	{	// Persisted value or 'Command' being set here
		textPut("text", p->value(), PNL_MAIN, "keyboard");
	}
	else if( p->command() == "preset")
	{
		if ( p->value().length() > 0 )
		{
			controlShow(PNL_MAIN, "preset");
			textPut("text", p->value(), PNL_MAIN, "preset");
		}
		else
		{
			controlHide(PNL_MAIN, "preset");
		}
	}

	// ***** CONNECTIONS EVENTS HELPER LIST *****
	else if( p->command() == "_events" )
	{	// Helper-list of everything in this component generated by hostNotify's
		bncs_stringlist sl;

		sl << "notify=*";		
		
		return sl.toString( '\n' );
	}

	// ***** CONNECTIONS COMMANDS HELPER LIST *****
	else if( p->command() == "_commands" )
	{	// Helper-list of any commands/parameters you might want to set at run-time
		bncs_stringlist sl;
		
		sl << "myParam=[value]";
		
		return sl.toString( '\n' );
	}

	return "";
}

// timer events come here
void popup_keyboard::timerCallback( int id )
{
	switch( id )
	{
	case TIMER_SETUP:
		timerStop(id);
		break;

	default:	// Unhandled timer event
		timerStop(id);
		break;
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Callbacks above - Methods below ///////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


